# 标准库文档

## 目录
1. [CSS标准](#css标准)

    1. [选择器类型](#选择器类型)
1. [ECMAScript标准（部分）](#ecmascript标准部分)

    1. [`Object`](#object)
    1. [`Array`](#array)
    1. [`String`](#string)
    1. [`Number`](#number)
    1. [`Function`](#function)
    1. [`JSON`](#json)
    1. [`Date`](#date)
    1. [`Math`](#math)
    1. [严格模式](#严格模式)
1. [ES6](#es6)

    1. [ECMAScript 2015（ES6）新增](#ecmascript-2015es6新增)
    1. [ECMAScript 2016（ES7）新增](#ecmascript-2016es7新增)
    1. [ECMAScript 2017（ES8）新增](#ecmascript-2017es8新增)
1. [Web API标准（部分）](#web-api标准部分)

    1. [文档对象模型（DOM）](#文档对象模型dom)
    1. [浏览器对象模型（BOM）](#浏览器对象模型bom)
1. [jQuery标准（部分）](#jquery标准部分)

    1. [`Deferred`](#deferred)
    1. [jQuery事件类型](#jquery事件类型)
    1. [jQuery事件处理函数的事件对象](#jquery事件处理函数的事件对象)
1. [其他](#其他)

    1. [JS特殊字符](#js特殊字符)

## CSS标准

### 选择器类型
1. CSS选择器

    >来自[阮一峰：CSS选择器笔记](http://www.ruanyifeng.com/blog/2009/03/css_selectors.html)、参考[W3C:selectors](https://www.w3.org/TR/selectors/#selectors)。

    1. 基本选择器

        1. `*`

            通配符选择器，匹配所有元素。
        2. `E`

            元素选择器，匹配使用E标签的元素。
        3. `.className`

            类选择器，匹配class属性中包含“className”的元素。
        4. `#idName`

            ID选择器，匹配id属性等于“idName”的元素。
    2. 关系选择器

        1. `E1,E2`

            多元素选择器，同时匹配E1元素或E2元素。

        >派生选择器：通过依据元素在其位置的上下文关系来定义样式。因此下面4个是派生选择器。

        2. `E1 E2`

            后代元素选择器，匹配属于E1元素后代的E2元素。
        3. `E1>E2`

            子元素选择器，匹配E1元素的子元素E2。
        4. `E1+E2`

            相邻兄弟选择器，匹配紧随E1元素之后的同级元素E2。
        5. `E1~E2`

            通用兄弟选择器，匹配在E1元素之后的同级E2元素。
    3. 属性选择器

        >1. 属性值的**引号**可加可不加；若属性值含有**空格**或**特殊字符**，必须用引号包围。
        >2. 建议始终用（双）引号包围属性值。

        1. `[attrName]`

            匹配具有“attrName”属性的元素，不考虑它的值。
        2. `[attrName=val]`

            匹配“attrName”属性等于“val”的元素。
        3. `[attrName~=val]`

            匹配“attrName”属性具有多个空格分隔的值、其中一个值等于“val”的元素。
        4. `[attrName|=val]`

            匹配“attrName”属性等于“val”或以“val-”开头的元素。

            >主要用于lang属性，如"en"、"en-us"、"en-gb"等。
        5. `[attrName^=val]`

            属性“attrName”的值以“val”开头的元素。
        6. `[attrName$=val]`

            属性“attrName”的值以“val”结尾的元素。
        7. `[attrName*=val]`

            属性“attrName”的值包含“val”字符串的元素。
    4. 伪元素选择器

        1. `:before`

            在元素之前插入生成的内容。
        2. `:after`

            在元素之后插入生成的内容。
        3. `:first-line`

            匹配元素的第一行。
        4. `:first-letter`

            匹配元素的第一个字母。
    5. 伪类选择器

        1. 普通伪类

            1. `:link`

                匹配未被点击的链接。
            2. `:visited`

                匹配已被点击的链接。
            3. `:active`

                匹配鼠标已经对其按下、还没有释放的元素。
            4. `:hover`

                匹配鼠标悬停其上的元素。
            5. `:focus`

                匹配获得当前焦点的元素。
            6. `:lang(val)`

                匹配lang属性等于“val”的元素。
        2. 与用户界面有关的伪类

            1. `:enabled`

                匹配表单中激活的元素。
            2. `:disabled`

                匹配表单中禁用的元素。
            3. `:checked`

                匹配表单中被选中的`radio`（单选框）或`checkbox`（复选框）。
            4. `::selection`

                匹配用户当前选中的元素（如鼠标或其他选择设备选中的部分）。

                >jQuery选择器无法选中内容；仅能作为CSS选择器添加样式属性。
        3. 结构性伪类

            1. `:root`

                匹配文档的根元素，对于HTML文档，就是HTML元素。
            2. `:nth-child(num)`

                匹配其父元素的第num个子元素，第一个编号为1。
            3. `:nth-last-child(num)`

                匹配其父元素的倒数第num个子元素，倒数第一个编号为1。
            4. `:nth-of-type(num)`

                与`:nth-child(num)`作用类似，但是仅匹配使用同种标签的元素。
            5. `:nth-last-of-type(num)`

                与`:nth-last-child(num)`作用类似，但是仅匹配使用同种标签的元素。
            6. `:first-child`

                匹配父元素的第一个子元素，等同于`:nth-child(1)`。
            7. `:last-child`

                匹配父元素的最后一个子元素，等同于`:nth-last-child(1)`。
            8. `:first-of-type`

                匹配父元素下使用同种标签的第一个子元素，等同于`:nth-of-type(1)`。
            9. `:last-of-type`

                匹配父元素下使用同种标签的最后一个子元素，等同于`:nth-last-of-type(1)`。
            10. `:only-child`

                匹配父元素下仅有的一个子元素，等同于`:first-child:last-child`或`:nth-child(1):nth-last-child(1)`。
            11. `:only-of-type`

                匹配父元素下使用同种标签的唯一一个子元素，等同于`:first-of-type:last-of-type`或`:nth-of-type(1):nth-last-of-type(1)`。
            12. `:empty`

                匹配一个不包含任意子元素的元素，注意，文本节点也被看作子元素。
            13. `:not(selector)`

                匹配不符合“selector”选择器的元素，注意，“selector”不能再包含`:not`。
            14. `:target`

                匹配文档URI的片段标识符，对应相同id属性的元素。
2. jQuery专有选择器

    >来自[jQuery:Selectors](https://api.jquery.com/category/selectors/)。

    jQuery兼容CSS所有选择器，并进行了扩展。

    >因为不是CSS规范的一部分，专有选择器无法利用本机DOM的`document.querySelectorAll`提升性能。为了提高代码性能，建议使用`filter`、`not`、`has`、`eq`等jQuery方法以及转化为CSS规范的选择器，来合理使用。

    1. `[attrName!=val]`

        匹配“attrName”属性不等于“val”的元素。
    2. `:first`

        匹配文档顺序的第一个元素。
    3. `:last`

        匹配文档顺序的最后一个元素。
    4. `:eq(num)`

        匹配文档顺序的第num个元素，0位第一个，-1为倒数第一个。
    5. `:even`

        匹配文档顺序的偶数元素，索引为0、2、4…。
    6. `:odd`

        匹配文档顺序的奇数元素，索引为1、3、5…。
    7. `:gt(num)`

        匹配索引大于（不包括等于）num的元素，0位第一个，-1为倒数第一个。
    8. `:lt(num)`

        匹配索引小于（不包括等于）num的元素，0位第一个，-1为倒数第一个。
    9. `:button`

        匹配`button, [type=button]`的元素。
    10. `:file`

        匹配`['type=file']`的元素。
    11. `:image`

        匹配`[type=image]`的元素。
    12. `:input`

        匹配`input, textarea, select, button`的元素。
    13. `:password`

        匹配`[type=password]`的元素。
    14. `:radio`

        匹配`[type=radio]`的元素。
    15. `:reset`

        匹配`[type=reset]`的元素。
    16. `:submit`

        匹配`[type=submit]`的元素。
    17. `:text`

        匹配`[type=text]`的元素。
    18. `:selected`

        匹配选中的元素（适用于`<option>`）。
    19. `:parent`

        匹配一个包含任意子元素的元素，注意，文本节点也被看作子元素。
    20. `:contains(val)`

        匹配含有“val”字符串（区分大小写）的元素，可以是后代包含。
    21. `:animated`

        匹配此时处于动画进度中的元素。
    22. `:has(selector)`

        匹配符合“selector”选择器的元素。
    23. `:header`

        匹配`h1, h2, h3, h4, h5, h6`的元素。
    24. `:hidden`

        匹配隐藏的元素。
    25. `:visible`

        匹配显示的元素。

---
## ECMAScript标准（部分）

### `Object`

>来自[MDN:Object](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#Properties)。

1. `Object`构造函数：

    ><details>
    ><summary>概念解释</summary>
    >
    >1. `冻结（freeze）` > `密封（seal）` > `不可扩展（preventExtensions）`。
    >2. 属性描述：
    >
    >    1. 数据属性：
    >
    >        1. `Configurable`
    >
    >            是否能修改描述符，是否能删除属性。默认false。
    >        2. `Enumerable`
    >
    >            是否被枚举。默认false。
    >        3. `Writable`
    >
    >            属性是否能被赋值运算符改变。默认false。
    >        4. `Value`
    >
    >            属性的值。默认undefined。
    >    2. 访问器属性：
    >
    >        1. `Configurable`
    >        2. `Enumerable`
    >        3. `Get`
    >
    >            属性的getter方法，该方法返回值为属性值。默认undefined。
    >        4. `Set`
    >
    >            属性的setter方法，该方法接受一个参数，并把参数赋值给属性。默认undefined。
    >3. 属性描述对象：
    >
    >    ```javascript
    >    {
    >        '属性名1': {
    >            描述名1: 描述值1,
    >            描述名2: 描述值2
    >        },
    >        '属性名2': {
    >            描述名1: 描述值1,
    >            描述名2: 描述值2
    >        }
    >    };
    >    ```
    >
    >    1. 属性描述对象 = `{属性名: 属性描述}`
    >
    >        `Object.defineProperties()`第二个参数、`Object.create()`第二个参数。
    >    2. 属性描述 = `{描述名: 描述值}`。
    >
    >        `Object.defineProperty()`第三个参数、`Object.getOwnPropertyDescriptor()`返回值。
    ></details>

    1. `Object.freeze(对象)`

        1. 描述：冻结对象。
        2. 返回：修改的对象。

        >冻结：不能添加新的属性、不能修改和删除已有属性的值。对象永远不可变。
    2. `Object.isFrozen(对象)`

        1. 描述：判断是否冻结。
        2. 返回：`true/false`。
    3. `Object.seal(对象)`

        1. 描述：密封对象。
        2. 返回：修改的对象。

        >密封：不能添加新的属性、不能删除已有属性，不能修改已有属性的可配置性、可枚举性、可写性，但可能可以修改已有属性的值。
    4. `Object.isSealed(对象)`

        1. 描述：判断是否密封。
        2. 返回：`true/false`。
    5. `Object.preventExtensions(对象)`

        1. 描述：不可扩展对象。
        2. 返回：修改的对象。

        >不可扩展：不能添加新的属性，可以删除和修改已有属性。
    6. `Object.isExtensible(对象)`

        1. 描述：判断是否可扩展。
        2. 返回：`true/false`。
    7. `Object.defineProperty(对象, 属性名, 属性描述)`

        1. 描述：新建或修改对象的属性。
        2. 返回：修改的对象。
    8. `Object.defineProperties(对象, 属性描述对象)`

        1. 描述：新建或修改对象的多个属性。
        2. 返回：修改的对象。
    9. `Object.create(原型对象[, 属性描述对象])`

        1. 描述：新建对象，用原型对象当做原型，用属性描述对象当做属性。
        2. 返回：一个对象。
    10. `Object.setPrototypeOf(目标对象, 原型对象)`

        1. 描述：用原型对象覆盖目标对象的原型（`[[Prototype]]`）。
        2. 返回：修改的目标对象。
    11. `Object.getPrototypeOf(对象)`

        1. 描述：返回对象的原型（`[[Prototype]]`）。
        2. 返回：一个对象。
    12. `Object.assign(目标对象, 多个源对象)`

        1. 描述：将所有可枚举属性从多个源对象复制到目标对象。
        2. 返回：修改的目标对象。
    13. `Object.is(第一个值, 第二个值)`

        1. 描述：来判断两个值是否是同一个值。
        2. 返回：`true/false`。
    14. `Object.getOwnPropertyDescriptor(对象, 属性名)`

        1. 描述：返回自有（不在原型链上）属性的属性描述。
        2. 返回：属性描述；若不存在属性，则`undefined`。
    15. `Object.entries(对象)`

        1. 描述：返回所有自有（不在原型链上）可枚举属性的名值对数组组成的数组。
        2. 返回：一个数组。

        >e.g. `Object.entries({ a: 'x', b: 42 });/* [['a', 'x'], ['b', 42]]*/`
    16. `Object.values(对象)`

        1. 描述：返回所有自有（不在原型链上）可枚举属性的属性值组成的数组。
        2. 返回：一个数组。
    17. `Object.keys(对象)`

        1. 描述：返回所有自有（不在原型链上）可枚举属性的属性名组成的数组。
        2. 返回：一个数组。
    18. `Object.getOwnPropertyNames(对象)`

        1. 描述：返回所有自有（不在原型链上）可枚举、不可枚举属性的属性名组成的数组。
        2. 返回：一个数组。
    19. `Object.getOwnPropertySymbols(对象)`

        1. 描述：返回所有自有（不在原型链上）的symbol属性名组成的数组。
        2. 返回：一个数组。
    20. `Object.length`等于`1`
2. Object原型链（继承给所有实例）：

    1. `Object.prototype.constructor`等于`Object`
    2. `Object.prototype.hasOwnProperty(属性名)`

        1. 描述：判断是否是自有（不在原型链上）属性。
        2. 返回：`true/false`。
    3. `Object.prototype.isPrototypeOf(对象)`

        1. 描述：判断是否在对象的原型链上。
        2. 返回：`true/false`。

        - `对象 instanceof 构造函数`

            1. 描述：判断`构造函数.prototype`是否存在于对象的原型链上。
            2. 返回：`true/false`。

        >```javascript
        >// e.g.
        >Object.prototype.isPrototypeOf([]); //true
        >[] instanceof Object;               //true
        >```
    4. `Object.prototype.propertyIsEnumerable(属性名)`

        1. 描述：判断是否是可枚举的自有（不在原型链上）属性。
        2. 返回：`true/false`。
    5. `Object.prototype.toString()`

        1. 描述：返回表示该对象的字符串。
        2. 返回：一个字符串。
    6. `Object.prototype.toLocaleString()`

        1. 描述：调用`toString`。用于被本地化对象方法覆盖。
        2. 返回：一个字符串。
    7. `Object.prototype.valueOf()`

        1. 描述：返回原始值。
        2. 返回：原始值。

### `Array`

>来自[MDN:Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#.E5.85.88.E5.89.8D.E7.9A.84.E7.89.88.E6.9C.AC.E4.B8.AD.E7.9A.84.E8.A1.8C.E4.B8.BA)。

1. Array构造函数：

    1. `Array.from(类似数组[, 处理方法[, this替代]])`

        1. 描述：从类似数组或可迭代对象创建新的数组实例。处理方法会对新创建的数组执行类似map操作。
        2. 返回：一个数组。
    2. `Array.isArray(值)`

        1. 描述：确定是否为数组。
        2. 返回：`true/false`。
    3. `Array.of(数组的每一项)`

        1. 描述：根据参数创建数组。
        2. 返回：一个数组。

        >与`Array`构造函数区别在对单个参数的返回值：`Array.of(3);/* [3]*/`、`new Array(3);/* [, , ,]*/`。
    4. `Array.length`等于`1`
2. Array原型链（继承给所有实例）：

    1. `Array.prototype.constructor`等于`Array`
    2. `Array.prototype.length`等于`0`
    3. 改变调用对象（mutator方法）：

        1. `Array.prototype.push(添加的多项)`

            1. 描述：将一个或多个元素添加到数组的末尾。
            2. 返回：数组新长度。
        2. `Array.prototype.pop()`

            1. 描述：从数组中删除最后一个元素。
            2. 返回：从数组中删除的元素；若数组为空，则`undefined`。
        3. `Array.prototype.unshift(添加的多项)`

            1. 描述：将一个或多个元素添加到数组的开头。
            2. 返回：数组新长度。
        4. `Array.prototype.shift()`

            1. 描述：从数组中删除第一个元素。
            2. 返回：从数组中删除的元素；若数组为空，则`undefined`。
        5. `Array.prototype.reverse()`

            1. 描述：颠倒数组中元素的位置。
            2. 返回：修改后的数组。
        6. `Array.prototype.sort([排序方法])`

            1. 描述：排序数组。
            2. 返回：修改后的数组。

            ><details>
            ><summary>排序方法</summary>
            >
            >1. `function (a, b) {/* 返回小于0，a在b前；返回等于0，位置不变；返回大于0，a在b后*/}`。
            >2. 若是比较数字，`function (a, b) {return a - b;}`是升序。
            ></details>
        7. `Array.prototype.splice(开始索引[, 删除数量[, 添加的多项]])`

            1. 描述：删除现有元素（，并添加新元素）。
            2. 返回：删除元素的数组；若没有删除，则`[]`。

            >若删除数量为空，则删除索引之后的所有项。
        8. `Array.prototype.copyWithin(目标索引[, 源开始索引[, 结束源索引]])`

            1. 描述：浅复制数组的一部分到同一数组中的另一个位置。
            2. 返回：修改后的数组（数组长度不变）。
        9. `Array.prototype.fill(填充的值[, 开始索引[, 结束索引]])`

            1. 描述：将数组的所有元素从开始索引填充到具有静态值的结束索引。
            2. 返回：修改后的数组。
    4. 不改变调用对象（accessor方法）：

        1. `Array.prototype.concat(多个数组)`

            1. 描述：合并多个数组。
            2. 返回：合并的新数组。
        2. `Array.prototype.join([分割内容])`

            1. 描述：将数组的所有元素连接成字符串。
            2. 返回：字符串。

            >参数为空，默认为`,`；参数为`''`，则元素之间没有间隙。
        3. `Array.prototype.slice([开始索引[, 结束索引]])`

            1. 描述：浅拷贝从开始到结束（不包括结束）的数组内容。
            2. 返回：提取元素的新数组；若无内容，则`[]`。
        4. `Array.prototype.indexOf(查找的元素[, 开始索引])`

            1. 描述：向后查找数组中第一个给定元素。
            2. 返回：索引；若不存在，则`-1`。

            >开始索引默认为0。
        5. `Array.prototype.lastIndexOf(查找的元素[, 开始索引])`

            1. 描述：向前查找数组中第一个给定元素。
            2. 返回：索引；若不存在，则`-1`。

            >开始索引默认为数组长度-1。
        6. `Array.prototype.includes(查找的元素[, 开始索引])`

            1. 描述：判断当前数组是否包含给定元素。
            2. 返回：`true/false`。
        7. `Array.prototype.toString()`

            1. 描述：对每项调用`toString`，再调用`Array.prototype.join`连接。
            2. 返回：字符串。
        8. `Array.prototype.toLocaleString()`

            1. 描述：对每项调用`toLocaleString`，再调用`Array.prototype.join`连接。
            2. 返回：字符串。
        9. 遍历方法：

            1. `Array.prototype.forEach(回调函数(当前值, 索引, 数组整体)[, this替代])`

                1. 描述：对数组的每个元素执行一次提供的函数。跳过空位。
                2. 返回：`undefined`。

                >回调函数`return`无意义。
            2. `Array.prototype.map(回调函数(当前值, 索引, 数组整体)[, this替代])`

                1. 描述：数组中的每个元素调用提供的函数，组成新的数组。跳过空位（保留空位至新数组）。
                2. 返回：一个新的数组。

                >回调函数`return`的值为新数组每个项的值；空位保留至原始位置。
            3. `Array.prototype.filter(回调函数(当前值, 索引, 数组整体)[, this替代])`

                1. 描述：使用提供的函数测试所有元素，并创建包含所有通过测试的元素的新数组。跳过空位。
                2. 返回：一个新的数组；若都不通过，则`[]`。

                >回调函数`return`的值为真，则把原项添加进新数组，为假则丢弃；空位丢弃。
            4. `Array.prototype.every(回调函数(当前值, 索引, 数组整体)[, this替代])`

                1. 描述：测试数组中是否所有元素都通过提供的函数。跳过空位。
                2. 返回：`true/false`。
            5. `Array.prototype.some(回调函数(当前值, 索引, 数组整体)[, this替代])`

                1. 描述：测试数组中是否有一个元素通过提供的函数。跳过空位。
                2. 返回：`true/false`。
            6. `Array.prototype.find(回调函数(当前值, 索引, 数组整体)[, this替代])`

                1. 描述：查找数组中第一个元素通过提供的函数。跳过空位。
                2. 返回：一个元素；若都不通过，则`undefined`。
            7. `Array.prototype.findIndex(回调函数(当前值, 索引, 数组整体)[, this替代])`

                1. 描述：查找数组中第一个元素通过提供的函数。跳过空位。
                2. 返回：索引；若都不通过，则`-1`。
            8. `Array.prototype.reduce(回调函数(上一次调用返回的值, 当前值, 索引, 数组整体)[, 第一次调用回调函数的第一个参数])`

                1. 描述：向后对数组应用提供的函数。跳过空位。
                2. 返回：函数累计处理的最后一个结果。
            9. `Array.prototype.reduceRight(回调函数(上一次调用返回的值, 当前值, 索引, 数组整体)[, 第一次调用回调函数的第一个参数])`

                1. 描述：向前对数组应用提供的函数。跳过空位。
                2. 返回：函数累计处理的最后一个结果。
            10. `Array.prototype.values()`

                1. 描述：返回新的Array迭代器对象，该对象包含数组每个索引的值。
                2. 返回：一个Array迭代器对象。

                >等于：`Array.prototype[Symbol.iterator]()`。
            11. `Array.prototype.keys()`

                1. 描述：返回新的Array迭代器，它包含数组中每个索引的键。
                2. 返回：一个Array迭代器对象。
            12. `Array.prototype.entries()`

                1. 描述：返回新的Array迭代器对象（包含数组中每个索引的键-值对）。
                2. 返回：一个Array迭代器对象。

### `String`

>来自[MDN:String](https://developer.mozilla.org/cn/docs/Web/JavaScript/Reference/Global_Objects/String#Methods)。

1. String构造函数：

    1. `String.fromCharCode(多个Unicode数字)`

        1. 描述：使用Unicode值创建字符串。
        2. 返回：一个字符串。
        
        >可以通过`\u+4位16进制数的Unicode值`输出字符串。如`'\u00a9' === '©'`。
    2. `String.fromCodePoint(多个代码点序列数字)`

        1. 描述：使用代码点序列创建字符串。
        2. 返回：一个字符串。
        
        >ES6可以通过`\u{代码点序列}`转化出字符串。如`'\u{1F4A9}' === '💩' === '\ud83d\udca9'`。
    3. `String.raw 模板字符串`

        1. 描述：获取模板字符串的原始字面量值。
        2. 返回：一个字符串。
    4. `String.length`等于`1`
2. String原型链（继承给所有实例）：

    1. `String.prototype.constructor`等于`String`
    2. `String.prototype.length`等于`0`
    3. 跟HTML无关的方法：

        >String的方法均不改变调用对象（accessor方法）。

        1. `String.prototype.substr(开始索引[, 提取长度])`

            1. 描述：复制从开始索引的指定长度的字符串内容。
            2. 返回：截取的字符串。

            >若开始索引为负数，则加上字符串长度；若提取长度为0或负数，则返回`''`。
        2. `String.prototype.substring(开始索引[, 结束索引])`

            1. 描述：复制从开始到结束（不包括结束）的字符串内容。
            2. 返回：截取的字符串。

            >若参数为负数或`NaN`，则转换为0；若参数大于长度，则为转换为长度；若结束索引小于开始索引，则参数前后替换位置。
        3. `String.prototype.slice(开始索引[, 结束索引])`

            1. 描述：复制从开始到结束（不包括结束）的字符串内容。
            2. 返回：截取的字符串。

            >若参数为负数，则加上字符串长度；若结束索引比开始索引小，则返回`''`。
        4. `String.prototype.split([分割内容[, 限定分割数量]])`

            1. 描述：将字符串分割成数组。
            2. 返回：一个数组。

            >分割内容可以是正则表达式。
        5. `String.prototype.indexOf(查找的元素[, 开始索引])`

            1. 描述：向后查找字符串中第一个给定元素（查找到的元素首部为返回的索引）。
            2. 返回：索引；若不存在，则`-1`。

            >开始索引默认为0。
        6. `String.prototype.lastIndexOf(查找的元素[, 开始索引])`

            1. 描述：向前查找字符串中第一个给定元素（查找到的元素首部为返回的索引）。
            2. 返回：索引；若不存在，则`-1`。

            >开始索引默认为数组长度。
        7. `String.prototype.includes(查找的元素[, 开始索引])`

            1. 描述：判断当前字符串是否包含给定元素。
            2. 返回：`true/false`。
        8. `String.prototype.startsWith(查找的元素[, 开始索引])`

            1. 描述：判断当前字符串是否以给定元素作为开头。
            2. 返回：`true/false`。
        9. `String.prototype.endsWith(查找的元素[, 结尾索引])`

            1. 描述：判断当前字符串是否以给定元素作为结尾。
            2. 返回：`true/false`。
        10. `String.prototype.charAt(索引)`

            1. 描述：返回特定位置的字符。
            2. 返回：一个字符；若超出范围或空字符，则`''`。
        11. `String.prototype.charCodeAt(索引)`

            1. 描述：返回特定位置的Unicode值。
            2. 返回：一个整数；若超出范围或空字符，则`NaN`。
        12. `String.prototype.codePointAt(索引)`

            1. 描述：返回特定位置的UTF-16编码。
            2. 返回：一个整数；若超出范围或空字符，则`undefined`。
        13. `String.prototype.trim()`

            1. 描述：删除两端的空白字符。
            2. 返回：修改后的字符串。
        14. `String.prototype.repeat()`

            1. 描述：字符串重复0到正无穷次。
            2. 返回：修改后的字符串。
        15. `String.prototype.replace(正则或字符串, 替换字符串或替换方法)`

            1. 描述：新的内容来替换被匹配的内容。
            2. 返回：修改后的字符串。
        16. `String.prototype.search(正则表达式)`

            1. 描述：向后查找字符串中第一个匹配内容。
            2. 返回：索引；若不匹配，则`-1`。
        17. `String.prototype.match(正则表达式)`

            1. 描述：使用正则表达式与字符串相比较。
            2. 返回：一个匹配结果的数组；若不匹配，则`null`。
        18. `String.prototype.toLowerCase()`

            1. 描述：转换为小写。
            2. 返回：修改后的字符串。
        19. `String.prototype.toUpperCase()`

            1. 描述：转换为大写。
            2. 返回：修改后的字符串。
        20. `String.prototype.toLocaleLowerCase()`

            1. 描述：根据任何本地化特定的大小写映射，转换为小写。
            2. 返回：修改后的字符串。
        21. `String.prototype.toLocaleUpperCase()`

            1. 描述：根据任何本地化特定的大小写映射，转换为大写。
            2. 返回：修改后的字符串。
        22. `String.prototype.concat(多个字符串)`

            1. 描述：连接多个字符串。不影响原字符串。
            2. 返回：连接的新字符串。

            >因为性能和语法简洁原因，建议使用赋值操作符`+`代替。
        23. `String.prototype.valueOf()`

            1. 描述：返回String对象的原始值（primitive value）。
            2. 返回：一个字符串。
        24. `String.prototype.toString()`

            1. 描述：返回指定对象的字符串形式。
            2. 返回：一个字符串。

            >与`String.prototype.valueOf()`返回值一致。
        25. `String.prototype.localeCompare(比较的元素[, locales[, options]])`

            1. 描述：判断字符串的排列顺序（编码中的位置）是否在给定元素的前面、后面或相同。
            2. 返回：若在前，则负数；若在后，则正数；若相同，则`0`。
        26. `String.prototype.normalize([Unicode正规形式])`

            1. 描述：按照指定的一种Unicode正规形式将当前字符串正规化。
            2. 返回：修改后的字符串。
    4. HTML标签包裹方法：

        1. `String.prototype.anchor()`
        2. `String.prototype.big()`
        3. `String.prototype.blink()`
        4. `String.prototype.bold()`
        5. `String.prototype.fixed()`
        6. `String.prototype.fontcolor()`
        7. `String.prototype.fontsize()`
        8. `String.prototype.italics()`
        9. `String.prototype.link()`
        10. `String.prototype.small()`
        11. `String.prototype.strike()`
        12. `String.prototype.sub()`
        13. `String.prototype.sup()`

### `Number`

>来自[MDN:Number](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number)。

1. Number构造函数：

    1. 属性

        1. `Number.EPSILON`：两个可表示数之间的最小间隔。

            >`Math.abs(0.2 - 0.3 + 0.1) < Number.EPSILON;   // true`
        2. 能够准确地表示和正确地比较的安全整数：

            1. `Number.MAX_SAFE_INTEGER`：JS中最大的安全整数。

                >`Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1;  // true`
            2. `Number.MIN_SAFE_INTEGER`：JS中最小的安全整数。

                >`Number.MIN_SAFE_INTEGER === -(Math.pow(2, 53) - 1);   // true`

            - `Number.MAX_SAFE_INTEGER === -Number.MIN_SAFE_INTEGER;    // true`
        3. `Number.MAX_VALUE`：JS中能表示的最大数值。

            >`-Number.MAX_VALUE`：JS中能表示的最小数值。
        4. `Number.MIN_VALUE`：JS中能表示的最小正数。

            >`-Number.MIN_VALUE`：JS中能表示的最大负数。
        5. `Number.NaN`：`NaN`。
        6. 溢出数：

            1. `Number.POSITIVE_INFINITY`：正无穷大。

                >`Number.POSITIVE_INFINITY === Infinity;   // true`
            2. `Number.NEGATIVE_INFINITY`：负无穷大。

                >`Number.NEGATIVE_INFINITY === -Infinity;   // true`
    2. 方法

        1. `Number.isNaN(值)`

            1. 描述：判断是否为`NaN`且类型为`Number`。
            2. 返回：`true/false`。

            >`isNaN(值)`会先`Number(值)`再判断；`Number.isNaN(值)`若值不是数字类型则返回`false`。
        2. `Number.isFinite(值)`

            1. 描述：判断是否为有穷数且类型为`Number`。
            2. 返回：`true/false`。

            >`isFinite(值)`会先`Number(值)`再判断；`Number.isFinite(值)`若值不是数字类型则返回`false`。
        3. `Number.isInteger(值)`

            1. 描述：判断是否为整数且类型为`Number`。
            2. 返回：`true/false`。

            >`NaN`、`正负Infinity`不是整数。
        4. `Number.isSafeInteger(值)`

            1. 描述：判断是否为安全整数且类型为`Number`。
            2. 返回：`true/false`。

            >安全整数范围：`[-(Math.pow(2, 53) - 1), Math.pow(2, 53) - 1]`。
        5. `Number.parseInt`：`parseInt`。
        6. `Number.parseFloat`：`parseFloat`。
2. Number原型链（继承给所有实例）：

    1. `Number.prototype.toFixed([数字])`

        1. 描述：指定小数点后数字个数（默认为0），省去的四舍五入。
        2. 返回：一个字符串。
    2. `Number.prototype.toExponential([数字])`

        1. 描述：用指数形式，指定小数点后数字个数（默认为达到已有位数），省去的四舍五入。
        2. 返回：一个字符串。
    3. `Number.prototype.toPrecision([数字])`

        1. 描述：指定精确位数（默认则类似`Number.prototype.toString()`），省去的四舍五入。
        2. 返回：一个字符串。

        >在某些情况下会以指数表示法返回。
    4. `Number.prototype.toString([数字])`

        1. 描述：转化为指定进制数的字符串（默认为10进制）。
        2. 返回：一个字符串。
    5. `Number.prototype.valueOf()`

        1. 描述：返回原始值数字。
        2. 返回：一个数字。

### `Function`

>来自[MDN:Function](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function#属性和方法)。

1. Function构造函数：

    1. `Function.length`等于`1`
2. Function原型链（继承给所有实例）：

    1. `Function.prototype.constructor`等于`Function`
    2. `Function.prototype.length`等于`0`
    3. `Function.prototype.call(this替代[, 多个参数])`

        1. 描述：指定this和多个参数进行的函数调用。
        2. 返回：函数的返回值。
    4. `Function.prototype.apply(this替代[, 参数数组])`

        1. 描述：指定this和参数（数组形式）进行的函数调用。
        2. 返回：函数的返回值。
    5. `Function.prototype.bind(this替代[, 多个参数])`

        1. 描述：创建新函数，当被调用时，this被替代，并设置形参的值（不可改变，新函数的参数填补在原函数去除已设置形参的后面）。
        2. 返回：一个新函数。
    6. `Function.prototype.toString()`

        1. 描述：返回表示当前函数源代码的字符串。
        2. 返回：一个字符串。

### `JSON`

>来自[MDN:JSON](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON#Methods)。

1. `JSON.parse(JSON字符串[, 处理方法])`

    1. 描述：将JSON字符串解析为JS值。处理方法会改造转换完毕的JS值。
    2. 返回：JS值。
2. `JSON.stringify(JS值[, 处理方法或处理数组[, 缩进空格数量或缩进字符串]])`

    1. 描述：将JS值解析为JSON字符串。
    2. 返回：JSON字符串。

    >1. 非数组对象的属性不保证以特定的顺序出现在序列化后的字符串中。
    >2. 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。
    >3. `undefined`、`方法`、`symbol值`：
    >
    >    1. 非数组：被忽略
    >    2. 数组：被转换成`null`
    >4. 所有以`symbol`为属性键的属性都会被忽略。
    >5. 不可枚举的属性被忽略。

### `Date`

>来自[MDN:Date](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#.E5.B1.9E.E6.80.A7)。

1. 调用构造函数：

    1. `new Date([毫秒/时间字符串/年, 月[, 日[, 时[, 分[, 秒[, 毫秒]]]]]])`

        创建Date实例。
    2. `Date(参数无效)`

        创建当前时间的字符串。

    >无字面量格式。如果参数超出了合理范围，会调整到相邻的时间。
2. Date构造函数：

    1. `Date.now()`

        1. 描述：自1970-01-01 00:00:00 UTC到当前时间的毫秒。
        2. 返回：一个数字。
    2. `Date.parse(时间字符串)`

        1. 描述：自1970-01-01 00:00:00 UTC到时间字符串的毫秒。
        2. 返回：一个数字；若参数不合法，则`NaN`。
    3. `Date.UTC(年, 月[, 日[, 时[, 分[, 秒[, 毫秒]]]]])`

        1. 描述：自1970-01-01 00:00:00 UTC到参数日期的毫秒。
        2. 返回：一个数字。
    4. `Date.length`等于`7`
3. Date原型链（继承给所有实例）：

    1. getter：

        返回：一个数字。

        1. `Date.prototype.getTime()`

            描述：自1970-01-01 00:00:00 UTC到Date对象时间的毫秒。
        2. `Date.prototype.getTimezoneOffset()`

            描述：UTC相对于当前时区的时间差值（分钟）。
        3. `Date.prototype.getFullYear()`

            描述：年。
        4. `Date.prototype.getMonth()`

            描述：`[0, 11]`月。
        5. `Date.prototype.getDate()`

            描述：`[1, 31]`日。
        6. `Date.prototype.getHours()`

            描述：`[0, 23]`时。
        7. `Date.prototype.getMinutes()`

            描述：`[0, 59]`分。
        8. `Date.prototype.getSeconds()`

            描述：`[0, 59]`秒。
        9. `Date.prototype.getMilliseconds()`

            描述：`[0, 999]`毫秒。
        10. `Date.prototype.getDay()`

            描述：`[0, 6]`星期。
        11. `Date.prototype.getUTCFullYear()`

            描述：年（UTC）。
        12. `Date.prototype.getUTCMonth()`

            描述：`[0, 11]`月（UTC）。
        13. `Date.prototype.getUTCDate()`

            描述：`[1, 31]`日（UTC）。
        14. `Date.prototype.getUTCHours()`

            描述：`[0, 23]`时（UTC）。
        15. `Date.prototype.getUTCMinutes()`

            描述：`[0, 59]`分（UTC）。
        16. `Date.prototype.getUTCSeconds()`

            描述：`[0, 59]`秒（UTC）。
        17. `Date.prototype.getUTCMilliseconds()`

            描述：`[0, 999]`毫秒（UTC）。
        18. `Date.prototype.getUTCDay()`

            描述：`[0, 6]`星期（UTC）。
    2. setter：

        返回：一个数字（自1970-01-01 00:00:00 UTC到Date对象时间的毫秒）。

        >如果参数超出了合理范围，会调整到相邻的时间。

        1. `Date.prototype.setTime(距1970-01-01 00:00:00 UTC的毫秒)`

            描述：设置时间。
        2. `Date.prototype.setFullYear(年[, 月[, 日]])`

            描述：设置年。
        3. `Date.prototype.setMonth(月[, 日])`

            描述：设置月。
        4. `Date.prototype.setDate(日)`

            描述：设置日。
        5. `Date.prototype.setHours(时[, 分[, 秒[, 毫秒]]])`

            描述：设置时。
        6. `Date.prototype.setMinutes(分[, 秒[, 毫秒]])`

            描述：设置分。
        7. `Date.prototype.setSeconds(秒[, 毫秒])`

            描述：设置秒。
        8. `Date.prototype.setMilliseconds(毫秒)`

            描述：设置毫秒。
        9. `Date.prototype.setUTCFullYear(年[, 月[, 日]])`

            描述：设置年（UTC）。
        10. `Date.prototype.setUTCMonth(月[, 日])`

            描述：设置月（UTC）。
        11. `Date.prototype.setUTCDate(日)`

            描述：设置日（UTC）。
        12. `Date.prototype.setUTCHours(时[, 分[, 秒[, 毫秒]]])`

            描述：设置时（UTC）。
        13. `Date.prototype.setUTCMinutes(分[, 秒[, 毫秒]])`

            描述：设置分（UTC）。
        14. `Date.prototype.setUTCSeconds(秒[, 毫秒])`

            描述：设置秒（UTC）。
        15. `Date.prototype.setUTCMilliseconds(毫秒)`

            描述：设置毫秒（UTC）。
    3. 转换

        1. 转化为字符串：

            1. `Date.prototype.toDateString()`
            2. `Date.prototype.toISOString()`
            3. `Date.prototype.toJSON()`
            4. `Date.prototype.toLocaleDateString()`
            5. `Date.prototype.toLocaleString()`
            6. `Date.prototype.toLocaleTimeString()`
            7. `Date.prototype.toString()`
            8. `Date.prototype.toTimeString()`
            9. `Date.prototype.toUTCString()`
        2. 转换为数字：

            1. `Date.prototype.valueOf()`

### `Math`

>来自[MDN:Math](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math#Properties)。

1. 方法

    1. `Math.abs(数字)`

        返回：数字的绝对值。

    2. `Math.ceil(数字)`

        返回：数字向上取整后的整数值。
    3. `Math.floor(数字)`

        返回：数字向下取整后的整数值。
    4. `Math.round(数字)`

        返回：数字四舍五入后的整数值。
    5. `Math.random()`

        返回：`[0,1)`的伪随机数。
    6. `Math.max(多个数字)`

        返回：多个数字中的最大值。
    7. `Math.min(多个数字)`

        返回：多个数字中的最小值。
    8. `Math.pow(基数, 指数)`

        返回：基数的指数次幂。
    9. `Math.sqrt(数字)`

        返回：数字的平方根。
    10. `Math.log(数字)`

        返回：数字的自然对数。
    11. `Math.exp(数字)`

        返回：e的数字指数的值。

    >`1*弧度 = 1 * (180 / Math.PI)角度`。

    12. `Math.sin(弧度)`

        返回：弧度的正弦值。
    13. `Math.asin(数字)`

        返回：数字的反正弦值（弧度）。
    14. `Math.cos(弧度)`

        返回：弧度的余弦值。
    15. `Math.acos(数字)`

        返回：数字的反余弦值（弧度）。
    16. `Math.tan(弧度)`

        返回：弧度的正切值。
    17. `Math.atan(数字)`

        返回：数字的反正切值（弧度）。
    18. `Math.atan2(数字1, 数字2)`

        返回：数字2/数字1的反正切值（弧度）。
2. 属性

    1. `Math.PI`

        描述：圆周率，约等于3.14159。
    2. `Math.E`

        描述：欧拉常数，自然对数的底数, 约等于2.718。
    3. `Math.LN2`

        描述：2的自然对数, 约等于0.693。
    4. `Math.LN10`

        描述：10的自然对数, 约等于2.303。
    5. `Math.LOG2E`

        描述：以2为底E的对数, 约等于1.443。
    6. `Math.LOG10E`

        描述：以10为底E的对数, 约等于0.434。
    7. `Math.SQRT1_2`

        描述：1/2的平方根, 约等于0.707。
    8. `Math.SQRT2`

        描述：2的平方根，约等于1.414。

### 严格模式
>来自[MDN：严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)。

1. 作用范围：全局（一个代码块`<script>`内）或函数作用域。

    >合并一个全局的严格模式与其他非严格模式的代码，会导致所有合并代码均为严格模式。
2. 开启方式：作用域加上`"use strict";`或ES6 module默认要求。
3. 影响

    1. 消除静默失败，改为错误抛出。
    2. 修复了JS引擎难以执行优化的错误，（有时候）相同代码运行得更快。
    3. 禁用在ECMAScript的未来版本中可能会定义的一些语法。
4. 相对于非严格模式，增加的限制（违背则抛出错误）：

    1. 将拼写错误转成异常

        1. 不允许**意外**创建全局变量。
        2. 不允许对`不可写`或`只读`或`不可扩展`的属性赋值或删除（引起非严格模式静默失败的情况）。
        3. 不允许重名属性名、参数名。
        4. 不允许`0数字`、`'\0数字'`代表八进制。

            >`0o数字`是ES6支持的八进制数。
        5. 不允许给基本数据类型设置属性。

            >基本数据类型：`Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`。
    2. 简化变量使用

        1. 不允许使用`with`。
        2. 不允许删除变量。
    3. 安全

        1. `eval`不会在它的外层作用域引入变量。
        2. 不允许`eval`、`arguments`被绑定或赋值。
        2. `arguments`属性不与形参同步更新。

            >可以分别修改`arguments`属性或形参，两者不会同步。
        3. 不可删除、赋值、读取：`函数名.caller`、`函数名.arguments`、`arguments.caller`、`arguments.callee`。
        4. `this`总指向`undefined`，除非被`call/apply/bind`后`this`为传入的值。

            >在非严格模式，若是基本数据类型（除`undefined`、`null`外）使用`call/apply`，则`this`成为那个值的包装对象。
    4. 为未来的ES铺平道路

        1. 增加一些字符成为保留关键字（不能作为变量名、函数名或形参名）。

            `implements`、`interface`、`let`、`package`、`private`、`protected`、`public`、`static`、`yield`
        2. 不允许在语句块（`if`、`for`）中使用函数声明。

---
## ES6

>ES6是一个历史名词：一般指ES2015；也泛指ES5.1版以后的JS的下一代标准，涵盖了ES2015、ES2016、ES2017等。

### ECMAScript 2015（ES6）新增
1. `for-of`

    >`for-in`建议仅遍历对象。

    1. 遍历**可迭代对象**（Array、TypedArray、Map、Set、arguments、NodeList、迭代器、生成器、String）。

        >1. 可迭代协议（iterable protocol）：对象拥有`[Symbol.iterator]()`返回符合迭代器协议的对象。
        >2. 迭代器协议（iterator protocol）：对象实现`.next()`方法，该方法返回的对象包含`done`、`value`属性。
    2. 可以正确响应`break`、`continue`、`return`。
2. 迭代器（iterators）

    >是可迭代对象。

    1. 知道如何每次访问集合中的一项，并记录它的当前在序列中所在的位置。
    2. 提供了一个`next()`方法，返回序列中包含`done`、`value`的下一项对象。
3. 生成器（generators）

    >是迭代器。生成器内建`[Symbol.iterator]()`、`.next()`实现。

    1. `function*`声明、`yield`语句。
    2. 执行步骤：

        1. 调用生成器，返回一个生成器对象，函数体冻结不执行任何代码。
        2. 每次调用生成器对象的`.next()`，函数解冻并一直运行至下一个`yield`，再次冻结。
4. 字符串的扩展

    1. 模板字符串（template literals）
    
        `` ` ``
    
        1. 模板占位符
    
            `${部分JS表达式}`
    
            >值转换为字符串（`值.toString()`）输出至生成的字符串。
    
            - 不支持：
    
                1. ~~自动转义特殊字符~~
                2. ~~XSS预防~~
                3. ~~格式化特定语言的数字、日期~~
                4. ~~循环语句、条件语句~~
        2. 转义
    
            除了[字符串字面量转义内容](https://github.com/realgeoffrey/knowledge/blob/master/网站前端/前端内容/标准库文档.md#js特殊字符)，还需转义：`` \` `` `\${`。
        3. 多行书写
    
            >空格、新行、缩进，原样输出至生成的字符串。
        4. 可以使用`String.raw 模板字符串`同样内容。
        5. 标签模板（tagged template literals）
    2. Unicode加强
    
        `\u{代码点序列}`
5. 展开元素（spread operator）

    `...变量`

    把变量（对象、迭代器）全部拆分出使用。

>在某种程度上，展开元素和剩余元素相反：展开元素会“展开”数组变成多个元素，剩余元素会收集多个元素和“压缩”成一个单一的元素。

6. 剩余参数（rest parameters）

    `...形参名`

    1. 仅有最后一个参数可以被标记为剩余参数。
    2. `形参名`以数组形式使用，没有传参则为`[]`。
    3. 支持解构。
7. 默认参数（default parameters）

    `形参名=JS值`

    1. `JS值`可以使用前置的形参变量。
    2. 不设定默认参数，等效于设定`形参名=undefined`。
    3. 调用函数时，传递`undefined`等效于不传参，会使用默认参数。
    4. 支持解构。

>标准规定：使用剩余参数或默认参数的函数中，禁止使用~~arguments~~。

8. 解构赋值（destructuring assignment）

    1. 迭代器的解构：

        - 声明或赋值或函数形参：

            `[多个变量]=数组`

        1. 可以嵌套任意深度的数组。

            >e.g. `[a, [b, [c]], d] = [null, [1, ['c']], {4: 'd'}]; //等价于：a=null;b=1;c='c';d={4:'d'};`
        2. 可以留空位跳过被解构数组中的元素。

            >e.g. `[a, , d] = [null, [1, ['c']], {4: 'd'}];  //等价于：a=null;d={4:'d'};`
        3. 支持**默认参数**、**剩余参数**。
    2. 对象的解构：

        - 声明或赋值或函数形参

            1. 声明：`var {对象名}=对象`（对象名为变量）或`var {对象名:对象值}=对象`（对象值为变量）
            2. 赋值：`({对象名}=对象)`（对象名为变量）或`({对象名:对象值}=对象)`（对象值为变量）

        >e.g. `({a, b: c} = {a: 'a的值', b: 'c的值'});    //等价于：a='a的值';c='c的值';（没有b的赋值）`

        1. 可以嵌套任意深度的对象。
        2. 支持**默认参数**。
    3. 最后一个参数的`...`解构：

        把剩余的对象/数组，以对象/数组的形式全部赋值给最后一个解构变量。
    4. 基本数据类型的解构：

        1. `null`和`undefined`报错。
        2. 其他类型返回`undefined`。

    - 若解构没有对应值，则变量赋值为`undefined`。
    - 避免被当做块语句导致报错。
9. 箭头函数

    >适合非方法函数。

    1. 写法

        1. 函数体没有大括号，隐式返回表达式内容

            `参数 => 表达式` 或 `(多个参数) => 表达式`

            >表达式是对象字面量时，用`()`包裹。
        2. 函数体有大括号，不会自动返回内容

            `参数 => {块语句}`
        3. 无参数

            `() => 表达式` 或 `_ => 表达式`
    2. `this`

        不会创建自己的`this`，而使用封闭执行上下文最近的一个`this`值。

        >箭头函数并不会绑定`this`变量，它的作用域会如同寻常所做的一样一层层地去往上查找。对于`arguments`、`super`、`new.target`也同样如此。
    3. 不绑定`arguments`、`super`、`new.target`。
    4. 不能作为构造函数。
    5. 没有原型属性`prototype`。
    6. 不能用作生成器。
10. `Symbol`

    `Symbol([描述])`、`Symbol.for(字符串)`、`Symbol.标准属性`

    新增的基本数据类型。可用作属性键，能避免命名冲突的风险（创建一个Symbol值与其他任何值不会相等）。

    1. 当做属性键，不可枚举。
    2. 不可更改。
    3. 不可字符串拼接（`+`、`` `${Symbol类型}` ``）。
11. 键-值集合

    避免用户数据与内置方法冲突，不把数据作为属性暴露，有标准方法获取、修改内容，键-值不能通过原型链继承。

    1. `Set`

        1. 不包含相同元素。
        2. 值可以是任何类型。

        - 方法、属性：

            `new Set(可遍历数据)` `Set.prototype.size` `Set.prototype.has(值)` `Set.prototype.add(值)` `Set.prototype.delete(值)` `Set.prototype.clear()` `Set.prototype.forEach(回调函数(当前值, 索引, Set整体)[, this替代])`
    2. `Map`

        - 方法、属性：

            `new Map([键, 值])` `Map.prototype.size` `Map.prototype.has(键)` `Map.prototype.get(键)` `Map.prototype.set(键, 值)` `Map.prototype.delete(键)` `Map.prototype.clear()` `Map.prototype.forEach(回调函数(当前值, 索引, Map整体)[, this替代])`
    3. `WeakSet`

        1. 与`Set`类似，但仅支持：`new WeakSet(可遍历数据)` `Set.prototype.has(值)` `Set.prototype.add(值)` `Set.prototype.delete(值)`。
        2. 值必须是对象。
        3. 不可迭代、不可枚举。弱引用，引用的对象能够被垃圾回收。
    4. `WeakMap`

        1. 与`Map`类似，但仅支持：`new WeakMap([键, 值])` `WeakMap.prototype.has(键)` `WeakMap.prototype.get(键)` `WeakMap.prototype.set(键, 值)` `WeakMap.prototype.delete(键)`。
        2. 键必须是对象。
        3. 不可迭代、不可枚举。弱引用，引用的对象能够被垃圾回收。
12. 新的变量声明

    1. `let`（与`var`区别）：

        1. 拥有块级作用域。
        2. 声明的全局变量不是`window`的属性。
        3. `let`声明的变量直到控制流到达该变量被定义的代码行时才会被装载，所以在到达前使用会触发错误。

            >必要时提升，但没有提升的作用。在初始化之前，变量处于临时死区中并不可被访问。
        4. 在同一作用域用`let`重复定义变量会抛出一个语法错误。
        5. 在`for`、`for-in`、`for-of`语句中声明的`let`，每次迭代时都重新绑定。
    2. `const`

        1. 与`let`基本一致。
        2. 只能在声明时赋值，之后修改会引发语法错误。
13. Promise对象

    - 特性

        1. Promise对象的三种状态：pending（未完成）、resolved（已完成，fulfilled）、rejected（已失败）。
        2. 在Promise对象内部抛出错误被Promise对象获取，则直接reject，值为错误信息，函数内部不再继续向下执行。
        3. 非Promise对象当作resolve。
        4. Promise对象内部的错误仅会导致reject，不会向上抛出错误。
        5. Promise对象被reject（`reject()`或函数内抛出错误）却没有被`catch`或`then`处理，并且不在`await`调用的方法内进行，则会触发`window`的`unhandledrejection`事件，错误不会向上抛出（不会交给`window`的`error`处理）。
        6. 以下方法均返回Promise对象，都可以继续链式调用`then`或`catch`（解决回调地狱）。

    1. Promise构造函数：

        1. `new Promise(function (resolve, reject) {/* resolve(信息)则成功；reject(信息)则失败 */})`

            创建一个Promise实例，调用内部的resolve则resolve，调用内部的reject则reject。
        2. `Promise.all(可迭代参数)`

            可迭代参数都resolve则resolve，有任一reject则reject。

            >向下链式传递的Promise信息为所有成功的数组或第一个失败的信息。

            ><details>
            ><summary>e.g.</summary>
            >
            >```javascript
            >// jQuery模拟异步操作
            >function asyncFunc (resolve, reject, url) {
            >  $.ajax({ url: url })
            >    .done(function () {
            >      if (Math.random() > 0.5) {
            >        resolve('successed msg')
            >      } else {
            >        reject('failed msg')
            >      }
            >    })
            >    .fail(function () {reject('网络错误')})
            >}
            >
            >Promise.all([
            >  new Promise(function (resolve, reject) {
            >    asyncFunc(resolve, reject, '')
            >  }).catch(function (data) {return data}),
            >  new Promise(function (resolve, reject) {
            >    asyncFunc(resolve, reject, '失败请求')
            >  }).catch(function (data) {return data})
            >]).then(function (data) {console.log(data)})
            >```
            ></details>
        3. `Promise.race(可迭代参数)`

            可迭代参数首个resolve则resolve，首个reject则reject。
        4. 手动创建一个已经resolve或者reject的Promise

            1. `Promise.resolve(信息)`

                由`信息`决定是否是resolve还是reject。
            2. `Promise.reject(信息)`

                产生reject的Promise。
    2. Promise原型链（继承给所有实例）

        >链式调用：后面链式内容根据前面回调函数return值判断执行。若返回的是Promise对象，则等待其resolve或reject；若非Promise对象，则认为是resolved。

        1. `实例.then(resolve回调函数, reject回调函数)`

            实例resolve或reject则执行对应回调（参数为resolve或reject传递进的信息，返回值为后面链式内容的传入值）。
        2. `实例.catch(reject回调函数)`

            实例reject则执行回调（参数为reject传递进的信息，返回值为后面链式内容的传入值），实例resolve则跳过不执行。
14. 模块Module

    >参考[阮一峰：Module 的语法](http://es6.ruanyifeng.com/#docs/module)、[阮一峰：Module 的加载实现](http://es6.ruanyifeng.com/#docs/module-loader)。

    >`.js`文件、`<script>`遵循相同模块规则。

    - 概述

        1. 预编译阶段进行模块加载（静态分析）。
        2. 有自己单独作用域，不污染全局作用域，必须`export`才能输出给其他模块。在[严格模式](https://github.com/realgeoffrey/knowledge/blob/master/网站前端/前端内容/标准库文档.md#严格模式)下运行。

            >不推荐`window.属性`。
        3. `export`和`import`可以放在模块的任何位置，但必须处于模块顶层；若处于~~块级作用域内~~会报错。

            >预编译阶段无法解析块级作用域。因此无法进行条件判断或按需加载。
        4. 模块的加载逻辑：

            1. 预编译阶段确定模块加载顺序（最底层被依赖的模块——最后一个被`import`的模块，最先执行），代码运行时按照确定的顺序一次性执行整个模块代码。

                >感官上：遇到`import`时，不会跳去执行其他模块（模块执行顺序已经在预编译阶段确定），而是直接利用其他模块的引用。
            2. 一个模块仅能执行一次，无论被多少模块引入。模块引用只是获得其他模块的引用地址。
            3. “循环加载”：

                1. “循环加载”时忽略之前已经被依赖过的模块，最后加载最先出现的“循环加载”的模块。

                    ><details>
                    ><summary>循环依赖关系为<code>入口->a->b->c->a</code>，模块执行顺序为<code>c->b->a->入口</code>，完整执行完一个模块才会进入下一个模块执行</summary>
                    >
                    >e.g.
                    >```javascript
                    >// 按①②③④⑤⑥的顺序执行
                    >
                    >
                    >// 入口
                    >... // ⑤
                    >import 'a模块'; // ①②③④执行后，③④导出的内容
                    >... // ⑥
                    >
                    >
                    >// a模块
                    >... // ③
                    >import 'b模块'; // ①②执行后，①②导出的内容
                    >... // ④
                    >
                    >
                    >// b模块
                    >... // ①
                    >import 'a模块'; // a模块未执行，导出为空
                    >... // ②
                    >```
                    ></details>
                2. “循环加载”的最先被执行模块无法获取其他模块的`import`值，仅尝试声明。

                    1. 若`import`module实例，则实例对象被声明。
                    2. 若`import`内容为`var`，则变量被声明，但未赋值。
                    3. 若`import`内容为`let/const`，则变量未声明。

                    >1. 非“循环加载”的模块和“循环加载”第二个之后的模块，都能先获得`import`值（类似提升，还获得了引用值）。
                    >2. JS不关心是否发生了“循环加载”，只生成一个指向被加载模块的引用，需要开发者自己保证，真正取值时能够取到值。
            4. （除“循环加载”的第一个模块外，）模块可以提升使用`import`内容（类似变量提升，且可获得引用值）。
        5. `import`内容与原模块导出的变量是**动态绑定**，`import`出的内容不能赋值，但可以修改属性。

            >与`const`变量类似。
        6. ES6 module是一个多对象输出、多对象加载的模型：

            1. 输出任何模块内部的引用

                `export { A, B }`、`export { A as a, B }`、`export default A`、`export const A = { }`
            2. 加载模块中输出的任意引用

                `import A from ''`、`import * as A from ''`、`import { A, B } from ''`、`import { A as a, B } from ''`

        >（CORS）跨域的模块资源无法`import`引入，也无法通过`<script>`以模块方式加载。

    1. `export`

        模块可以导出多个内容，导出变量名不能重复（因此`default`只能导出一次）。

        >`default`可以当作默认变量来看待。

        1. `export 声明语句`
        2. `export {变量[, 变量]}`
        3. `export {变量 as 外号变量[, 变量 as 外号变量]}`

            >避免重命名；可以同一个变量使用多个外号变量。
        4. `export {变量[, 变量]}或{变量 as 外号变量[, 变量 as 外号变量]}或* form '模块'`

            >`export * form '模块'`导出除了`default`的内容，可以用`export { default } from '模块'`单独导出`default`。

            将其他模块的变量导入再导出，但本模块无法使用。

            ><details>
            ><summary>e.g.</summary>
            >
            >跨模块常量案例：
            >
            >```javascript
            >/* 单个常量文件 */
            >
            >// constants/db.js
            >export const db = {
            >  url: 'http://my.couchdbserver.local:5984',
            >  admin_username: 'admin',
            >  admin_password: 'admin password'
            >};
            >
            >// constants/user.js
            >export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];
            >
            >
            >
            >/* 合并到文件 */
            >
            >// constants/index.js
            >export { db } from './db';
            >export { users } from './users';
            >
            >
            >
            >/* 要使用的文件引入 */
            >
            >// script.js
            >import { db, users } from './constants/index';
            >```
            ></details>
        5. `export default 表达式` === `export {变量 as default}`

            ><details>
            ><summary>e.g.</summary>
            >
            >```javascript
            >/* 表达式 */
            >number + 1
            >function() {}
            >ok ? 'YES' : 'NO'
            >Array.from(words).reverse().join('')
            >
            >/*
            >是语句，不是表达式
            >var a = 1
            >
            >流控制不会生效，请使用三元表达式
            >if ...
            >*/
            >```
            ></details>
    2. `import`

        1. `import {导出的变量[, 导出的变量]} from '模块'`
        2. `import {导出的变量 as 外号变量[, 导出的变量 as 外号变量]} from '模块'`

            >避免重命名。
        3. `import 外号变量 from '模块'` === `import {default as 外号变量} from '模块'`

            >仅接受模块导出的`default`内容。
        4. `import * as Module实例 from '模块'`

            >导出的变量（包括`default`）都成为`Module`实例的属性（相当于导出命名空间），以`Module实例.导出的变量`使用。
        5. `import '模块'`

            不引入模块里导出的内容，仅执行该模块代码。
    
    ><details>
    ><summary>在浏览器环境使用前提</summary>
    >
    >1. 开启浏览器Module功能：
    >
    >    1. Chrome地址输入`chrome:flags`，打开`Experimental Web Platform`。
    >    2. Firefox地址输入`about:config`，打开`dom.moduleScripts.enabled`。
    >    3. Edge 地址输入`about:flags`，打开`Experimental JavaScript Features`。
    >2. 在`<script>`添加`type="module"`。
    ></details>
15. Blob对象

    用二进制的方式展示、下载文件。

    File对象是特殊类型的Blob对象。

    ajax获取文件二进制内容，用Blob操作下载，无论什么格式均可行。
16. 代理

    `new Proxy(target, handler)`
17. 类Class
18. 子类Subclassing
19. 计算对象中的属性名

    `[JS表达式]`

    ```javascript
    var a = 'a b c'

    var obj = {
      [a]: 1,
      [1 + 1 + 'b']: 2
    }

    obj['a b c']    // 1
    obj['2b']       // 2
    ```
20. 简写对象中的属性方法

    >简写的属性方法不能作为构造函数。

    ```javascript
    var obj = {
      property (parameters) {/* ... */},          // 普通方法
      * generator (parameters) {/* ... */},       // 生成器方法
      async property (parameters) {/* ... */}     // async方法
      // 可以使用计算属性名
    }
    ```

    >```javascript
    >// 并非所有情况都可以用简写，以下情况不适合用简写
    >var obj = {
    >  a: _.debounce(function (e) {
    >    console.log(e)
    >  }, 500)
    >}
    >```

### ECMAScript 2016（ES7）新增
1. `Array.prototype.includes(查找的元素[, 开始索引])`

    判断当前数组是否包含给定元素。
2. `**`（幂运算符，exponentiation operator）

    e.g. `2 ** 3 === 8  /* 2的3次幂 */`

### ECMAScript 2017（ES8）新增
1. `async-await`异步函数

    <details>
    <summary>e.g.</summary>
    
    ```javascript
    // 模拟异步操作
    function asyncFunc () {

      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          if (Math.random() < 0.3) {
            resolve({ code: 200, msg: '这是resolve成功信息' })
          } else if (Math.random() < 0.5) {
            resolve({ code: 202, msg: '这是resolve失败信息' })
          } else {
            reject('这是reject失败信息')
          }
        }, 1)
      })
    }

    async function a () {
      try {
        let result = await asyncFunc()  // await方法抛出错误或返回Promise的reject，则不再向下执行，直接进入catch；否则await返回值为Promise的resolve，函数向下执行

        if (result && result.code === 200) {
          // 执行某些操作
          console.log('满足条件', result)
        } else {
          throw new Error('返回值不满足判断条件')
        }
      } catch (e) {
        // 执行某些操作
        console.log('捕获错误', e)
      }
    }

    a() // async方法返回的是Promise对象；若方法内抛出错误则是reject，否则是resolve（包括默认返回的undefined）；返回值或抛出异常值为向下传递的值
    ```
    </details>
2. 共享内存和原子
3. `Object.entries()`、`Object.values()`
4. `String.prototype.padStart`字符串填充
5. `Object.getOwnPropertyDescriptors`获取一个对象的所有自身属性的描述
6. 函数参数列表和调用中的尾逗号

---
## Web API标准（部分）

### 文档对象模型（DOM）
1. `document`

    >来自[MDN:document](https://developer.mozilla.org/zh-CN/docs/Web/API/Document)。

    1. 获取DOM

        1. 方法

            1. `document.querySelector(CSS选择器)`

                >或`dom.querySelector(CSS选择器)`。
            2. `document.querySelectorAll(CSS选择器)`

                >或`dom.querySelectorAll(CSS选择器)`。
            3. `document.getElementById(Id名)`
            4. `document.getElementsByTagName(标签名)`

                >`document.getElementsByTagNameNS(命名空间, 标签名)`
            5. `document.getElementsByClassName(类名)`
            6. `document.getElementsByName(name属性)`
        2. 属性（只读）

            1. `document.body`

                （可写）返回文档的`<body>`或`<frameset>`。
            2. `document.documentElement`

                返回文档的根元素（如HTML的`<html>`）。
            3. `document.head`

                返回文档中`<head>`。
            4. `document.styleSheets`

                返回文档中`<style>`、`<link rel="stylesheet">`组成的数组。
            5. `document.scripts`

                返回文档中`<script>`组成的数组。
            6. `document.images`

                返回文档中`<img>`组成的数组。
            7. `document.links`

                返回文档中具有`href`属性的`<area>`、`<a>`组成的数组。
            8. `document.embeds`

                返回文档中`<embed>`组成的数组。
            9. `document.forms`

                返回文档中`<form>`组成的数组。

### 浏览器对象模型（BOM）
1. `window`
2. `location`
3. `navigator`
4. `screen`
5. `history`

---
## jQuery标准（部分）

### `Deferred`

>参考[阮一峰：jQuery的deferred对象详解](http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html)、[阮一峰：jQuery.Deferred对象](http://javascript.ruanyifeng.com/jquery/deferred.html)、[jQuery：延迟对象](https://www.jquery123.com/category/deferred-object/)。

1. Deferred对象

    1. 创建Deferred对象：

        `$.Deferred()`
    2. Deferred对象的状态：

        1. 触发状态：

            1. 改变状态：

                `.resolve()`、`.resolveWith()`、`.reject()`、`.rejectWith()`

            2. 状态不改变，仅发起一个通知：

                `.notify()`、`notifyWith()`

            - 以上所有方法仅在pending状态有效

                1. `.resolve/resolveWith()`触发函数：`.done`、`.always()`、`.then(第一个参数)`
                2. `.reject/rejectWith()`触发函数：`.fail`、`.always()`、`.then(第二个参数)`、`.catch()`
                3. `.notify/notifyWith()`触发函数：`.progress()`、`.then(第三个参数)`
        2. 获得状态：`.state()`

            返回三者之一：`'pending'`、`'resolved'`、`'rejected'`。
    2. 当Deferred对象状态改变后（或发起`notify`通知），根据相应的状态触发回调

        1. 向下传递调用方法的对象本身：`.done()`、`.fail()`、`.progress()`、`.always()`。

            >Deferred对象调用则返回Deferred对象；Promise对象调用则返回Promise对象。

            <details>
            <summary>e.g.</summary>
            
            ```javascript
            var deferred = $.Deferred()
              .done(function (msg) {
                console.log('resolve', msg);
              })
              .fail(function (msg) {
                console.error('reject', msg);
              })
              .progress(function (msg) {
                console.log('notify', msg);
              })
              .always(function (msg) {
                console.log('always', msg);
              });

            //deferred.resolve('信息');   // 执行done，再执行always
            //deferred.reject('信息');    // 执行fail，再执行always
            //deferred.notify('信息');    // 执行progress
            ```
            </details>
        2. 向下传递回调函数的`return`内容：`.then(解决, 拒绝, 通知)`、`.catch(拒绝)`。

            >返回为Promise对象。

            <details>
            <summary>e.g.</summary>
            
            ```javascript
            var deferred = $.Deferred();
            var promise = deferred
              .then(
                function (e) {
                  return e;
                }, function (e) {
                  return e;
                }, function (e) {
                  return e;
                });

            promise
              .done(function (msg) {
                console.log('resolve', msg);
              })
              .fail(function (msg) {
                console.error('reject', msg);
              })
              .progress(function (msg) {
                console.log('notify', msg);
              })
              .always(function (msg) {
                console.log('always', msg);
              });

            //deferred.resolve('信息'); // 执行then第一个参数，再执行done，最后执行always
            //deferred.reject('信息');  // 执行then第二个参数，再执行fail，最后执行always
            //deferred.notify('信息');  // 执行then第三个参数，再执行progress
            ```
            </details>
        3. 且判断：`jQuery.when(Deferred对象或其他值)`。

            若传入的不是Deferred对象，则当做立即解决的值：`$.Deferred().resolve(参数)`。

            >返回为Promise对象。
    3. 改变为Promise对象：`.promise()`。
2. Promise对象

    >`Deferred对象`的子集。

    1. 相对于Deferred对象，Promise对象无法改变执行状态：

        1. 屏蔽~~与改变执行状态有关的方法~~：

            `resolve`、`resolveWith`、`reject`、`rejectWith`、`notify`、`notifyWith`
        2. 开放**与改变执行状态无关的方法**：

            `done`、`fail`、`progress`、`always`、`then`、`catch`、`promise`、`state`
    2. `$.ajax`返回`Promise对象`。
    3. 允许把所有jQuery对象设置为`Promise对象`（如动画方法后接`.promise().done(方法)`，使节点所有动画都结束后调用方法）。

[JSFiddle Demo](https://jsfiddle.net/realgeoffrey/ts50dmpa/)

### jQuery事件类型
1. 浏览器事件

    1. `resize`

        仅针对`$(window)`。

        1. 监听：`$(window).resize(func)`、`$(window).on('resize', func)`
        2. 手动触发：`$(window).resize()`、`$(window).trigger('resize')`
    2. `scroll`

        仅监听自己DOM的滚动，子节点滚动不触发。

        1. 监听：`.scroll(func)`、`.on('scroll', func)`
        2. 手动触发：`.scroll()`、`.trigger('scroll')`
    3. `error`（建议用原生事件）

        不冒泡。

        >jQuery不建议`on`等方式绑定`window`的`error`事件，只通过`window.onerror`定义。

        1. 监听：`.on('error', func)`
        2. 手动触发：`.trigger('error')`
    4. `load`（不可靠、建议用原生事件）

        适用于任何可使用`URL`关联的元素：`<img>`、`<link>`、`<script>`、`<iframe>`、`window`。

        >资源完全加载完毕后触发。

        1. 监听：`.on('load', func)`
        2. 手动触发：`.trigger('load')`
    5. `ready`

        仅针对`$(document)`。

        >DOM加载解析完毕后触发。

        1. 监听：`$(document).ready(func)`、`$(func)`、`$().ready(func)`
2. 表单事件

    1. `blur`

        不冒泡，直接绑定后无法监听子节点`blur`的冒泡。但可以用事件代理（自动转换为`focusout`），

        1. 监听：`.blur(func)`、`.on('blur', func)`
        2. 手动触发：`.blur()`、`.trigger('blur')`
    2. `focus`

        不冒泡，直接绑定后无法监听子节点`focus`的冒泡。但可以用事件代理（自动转换为`focusin`），

        1. 监听：`.focus(func)`、`.on('focus', func)`
        2. 手动触发：`.focus()`、`.trigger('focus')`
    3. `focusout`

        1. 监听：`.focusout(func)`、`.on('focusout', func)`
        2. 手动触发：`.focusout()`、`.trigger('focusout')`
    4. `focusin`

        1. 监听：`.focusin(func)`、`.on('focusin', func)`
        2. 手动触发：`.focusin()`、`.trigger('focusin')`
    5. `change`

        >按钮选择改变、文本内容修改并且失去焦点。

        1. 监听：`.change(func)`、`.on('change', func)`
        2. 手动触发：`.change()`、`.trigger('change')`
    6. `select`

        >鼠标选中输入框的文字。

        1. 监听：`.select(func)`、`.on('select', func)`
        2. 手动触发：`.select()`、`.trigger('select')`
    7. `submit`

        1. 监听：`.submit(func)`、`.on('submit', func)`
        2. 手动触发：`.submit()`、`.trigger('submit')`
3. 键盘事件

    1. `keydown`

        哪一个键被按下。按住不断触发。

        1. 监听：`.keydown(func)`、`.on('keydown', func)`
        2. 手动触发：`.keydown()`、`.trigger('keydown')`
    1. `keyup`

        哪一个键被按下。按住抬起仅触发一次。

        1. 监听：`.keyup(func)`、`.on('keyup', func)`
        2. 手动触发：`.keyup()`、`.trigger('keyup')`
    1. `keypress`

        实际输入的文本。按住不断触发。

        1. 监听：`.keypress(func)`、`.on('keypress', func)`
        2. 手动触发：`.keypress()`、`.trigger('keypress')`
4. 鼠标事件

    `mousedown`、`mouseup`、`click`、`dblclick`、`contextmenu`、`mousemove`、`hover`、`mouseenter`、`mouseleave`、`mouseover`、`mouseout`

### jQuery事件处理函数的事件对象

>`$dom.on(..., function (e) {});`，并假设`this`为默认值。

1. `e.originalEvent === window.event`
2. `e.target`：

    最深层被触发的元素（捕获的终点、冒泡的起点）；当冒泡时，`target`不会变化，因此`this`就有可能不等于`target`。
3. `e.currentTarget`：

    在事件冒泡过程中的当前DOM元素，`e.currentTarget === this`
4. `e.delegateTarget`：

    绑定的宿主。
5. `e.relatedTarget`：

    在事件中涉及的其它任何DOM元素。
6. `e.pageX/Y`：

    鼠标相对于文档的左/上边缘的位置。
7. `e.data`：

    传入处理函数的额外参数。
8. `e.namespace`：

    事件被触发时包含的命名空间。
9. `e.type`：

    事件类型。
10. `e.which`：

    返回键盘或鼠标（左键：1；中键：2；右键：3）的数字。
11. `e.result`：

    获取前一个事件的返回值。
12. `e.timeStamp`：

    触发时的时间戳。
13. `e.preventDefault()`：

    默认事件行为将不再触发。
14. `e.isDefaultPrevented()`：

    事件对象中是否调用过`e.preventDefault()`。
15. `e.stopPropagation()`：

    防止事件冒泡到DOM树上。
16. `e.isPropagationStopped()`：

    事件对象中是否调用过`e.stopPropagation()`。
17. `e.stopImmediatePropagation()`：

    阻止剩余的事件处理函数执行并且防止事件冒泡到DOM树上。
18. `e.isImmediatePropagationStopped()`：

    事件对象中是否调用过`e.stopImmediatePropagation()`。

- 也会把`window.event`的部分属性拷贝至`e`

---
## 其他

### JS特殊字符
1. 字符串字面量：

    >来自[MDN:在字符串中使用的特殊字符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#在字符串中使用的特殊字符)。

    转义字符：`\`。

    | 字符 | 表示的意义 |
    | :--- | :--- |
    | `'\''` | `"'"` |
    | `'\"'` | `'"'` |
    | `'\\'` | `'\'` |
    | `'\0'` | `null` |
    | `'\b'` | 退格符 |
    | `'\f'` | 换页符 |
    | `'\n'` | 换行符 |
    | `'\r'` | 回车符 |
    | `'\t'` | Tab (制表符) |
    | `'\v'` | 垂直制表符 |
    | `'\一至三个8进制数'` | 用8进制数指定Unicode的[Latin-1](https://zh.wikipedia.org/wiki/ISO/IEC_8859-1) |
    | `'\x两个16进制数'` | 用16进制数指定Unicode的Latin-1 |
    | `'\u四个16进制数'` | 用16进制数指定[Unicode](https://zh.wikipedia.org/wiki/Unicode字符列表) |
    | `'\u{一至六个16进制数}'` | 用16进制数指定Unicode的[码位](https://zh.wikipedia.org/wiki/码位) |

    >可以给其他所有字符前面添加`\`，`\`会被忽略（不建议的写法）。e.g. `'\a' === 'a'`。
2. 模板字符串：

    除了**字符串字面量**的转义内容，还需转义：

    | 字符 | 表示的意义 |
    | :--- | :--- |
    | `` \` `` | `` ` `` |
    | `\${` | `${`（单独出现`${`表示模板占位符的开始） |
3. 正则表达式字面量：

    转义字符：`\`。

    [转义内容](https://github.com/realgeoffrey/knowledge/blob/master/网站前端/JS正则表达式/README.md#特殊字符)。
