# 前端概念

从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的GUI（Graphical User Interface，图形用户界面）即为前端。

### 前端工程化
>参考[张云龙：前端工程——基础篇](https://github.com/fouber/blog/issues/10)。

1. 第一阶段：库/框架选型

    >提升开发效率。（使用自动化工具也能够提升开发效率，如浏览器自动刷新、IDE）
2. 第二阶段：简单构建优化

    >提升运行性能。

    对代码进行压缩、校验，以页面为单位进行简单的资源合并。
3. 第三阶段：JS/CSS模块化开发

    >提升维护效率。

    **分而治之**
    1. JS模块化方案：

        CommonJS/AMD/CMD/ES6 Module/UMD
    2. CSS模块化方案：

        sass/less/stylus等预处理器的import、mixin特性支持实现。
4. 第四阶段：前端工程化

    >优化部署、开发。

    1. 组件化开发

        >模块化开发的升华。

        1. 页面上的每个**独立的**可视/可交互区域视为一个组件；
        2. 每个组件对应一个**工程目录**，组件所需的各种资源都在这个目录下**就近维护**；
        3. 由于组件具有独立性，因此组件与组件之间可以**自由组合**；
        4. 页面只不过是组件的容器，负责组合组件形成功能完整的界面；
        5. 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。

    2. 资源管理

        >静态资源加载的技术实现。

        解决思路：
        1. 静态资源管理系统 = 资源表 + 资源加载框架
        2. [大公司的静态资源优化方案](https://github.com/fouber/blog/issues/6)：

            1. 配置超长时间的本地缓存 —— 节省带宽，提高性能
            2. 采用内容摘要（MD5）作为缓存更新依据 —— 精确的缓存控制
            3. 静态资源CDN部署 —— 优化网络请求
            4. 资源发布路径实现非覆盖式发布 —— 平滑升级

### 前端涉及内容
![前端涉及内容图](./images/fe-tech-1.png)

### 前端“增量”原则

1. “增量”原则：

    前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。
2. 由“增量”原则引申出的前端优化技巧几乎成为了**性能优化**的核心：

    1. 加载相关的按需加载、延迟加载、预加载、请求合并等策略；
    2. 缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案；
    3. 复杂的BigRender、BigPipe、Quickling、PageCache等技术。

### HTTP协议
>HTTP（HyperText Transfer Protocol，超文本传输协议）默认端口号80、无状态、以ASCII码传输。

1. HTTP报文组成：

    1. request

        请求行 请求头 请求消息主体

        ```http
        <method> <request-URL> <version>
        <headers>

        <entity-body>
        ```
    2. response

        状态行 响应头 响应正文

        ```http
        <version> <status code> <status description>
        <headers>

        <entity-body>
        ```

        >[状态码、状态描述](https://github.com/realgeoffrey/knowledge/blob/master/网站前端/前端概念/基础概念.md#http状态码http-status-code)。
2. HTTP流程简单概括：

    1. 获取域名的IP地址

        1. 搜索浏览器自身DNS缓存。
        2. 若缓存没找到或者已失效，搜索操作系统DNS缓存。
        3. 若没找到，读取本地HOST文件。
        4. 若没找到，发起一个DNS的系统调用。

            >1. 宽带运营商服务器查看本身缓存。
            >2. 若没找到，运营商服务器发起一个迭代DNS解析的请求。
            >
            >  1. 运营商服务器把结果返回给用户操作系统内核（以上只要成功获取IP地址，每一层都会缓存在自己的系统内以便调用）。
            >  2. 操作系统内核把结果返回浏览器。
    2. 建立TCP／IP连接

        - 发起HTTP“三次握手”（验证客户端），试图建立TCP／IP链接：

            首先客户端向服务端发SYN（同步请求），然后服务端回复SYN+ACK（同步请求应答），最后客户端回复ACK确认。

        >关闭TCP链接要“四次挥手”。
    3. 浏览器发送请求，服务器发送数据

        1. 建立TCP／IP成功后，浏览器即可向服务器发送HTTP请求。
        2. 服务器端接受到了这个请求，根据路径参数、经过后端处理之后，把结果的数据返回浏览器。
    4. 获取所有资源

        若获取的是HTML代码资源，里面的JS、CSS、图片也都必须通过一个个以上完整的HTTP请求步骤进行交通。
    5. 展示

        根据拿到的资源对页面进行渲染，最终呈现完整的页面。

### 页面载入解析步骤
>参考[全方位提升网站打开速度：前端、后端、新的技术](https://github.com/xitu/gold-miner/blob/master/TODO/building-a-shop-with-sub-second-page-loads-lessons-learned.md#前端性能)。

1. 页面载入解析步骤

    ![页面解析步骤图](./images/load-html-1.png)

    1. 增量式生成一个文档对象模型（DOM），解析页面内容（HTML标签）。
    2. 加载DOM中所有CSS，生成一个CSS对象模型（CSSOM），描述对页面内容如何设置样式。

        - 加载CSS和构造完整的CSSOM之前，**阻塞渲染**（Render Tree渲染被暂停）。
    3. 加载DOM中所有JS，对DOM和CSSOM进行访问和更改。

        1. HTML中出现JS，**阻塞解析**（DOM构造被暂停）。
        2. 下载脚本或内嵌脚本不用下载。
        3. 等待所有CSS被提取并且CSSOM被构造完毕。
        4. CSSOM被构造完毕后，执行脚本，访问和更改DOM和CSSOM。
        5. DOM构造继续进行。
    4. DOM和CSSOM构造完成后，进行渲染流水线：

        Render Tree（渲染树） >> Layout（布局）-> Paint（绘制） -> Composite（渲染层合并）。

        >一定要等待外链资源加载完毕（包括加载失败）才可以继续构建DOM或CSSOM。

    >无论阻塞渲染还是阻塞解析，资源文件会不间断按顺序加载。
2. 从输入URL到页面完成的优化

    1. 输入URL：

        >服务端对HTTP请求的优化。

        1. 服务器开启g-zip。
        2. 使用CDN。
        3. 对资源进行缓存：请求头添加Expires、Etags等。
        4. 减少DNS查找，设置合适的TTL值，避免重定向。
    2. 载入页面：

        >前端对CRP（Critical Rendering Path，关键呈现路径，优先显示与当前用户操作有关的内容）、代码性能的优化。

        1. 优化CRP：

            1. 减少关键资源

                首屏资源合并，非首屏资源异步加载。
            2. 最小化字节

                压缩，雪碧图等。

                >单个大文件需要多次与服务器往返来获取。
            3. 缩短CRP长度

                CSS放在HTML顶部，JS放在HTML底部。
        2. 技术上优化：

            1. 单页应用程序。
            2. 首屏直接加载资源，非首屏延迟加载。

                1. 图片延迟加载。
                2. 内容ajax加载。
                3. 功能文件按需加载。
            3. CSS选择器优化。
            4. HTML标签减少层级嵌套。
            5. JS代码性能优化。