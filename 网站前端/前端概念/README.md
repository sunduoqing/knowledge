# 前端概念

从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的GUI（Graphical User Interface，图形用户界面）即为前端。

### 前端涉及内容
![前端涉及内容图](./images/fe-tech-1.png)

### 前端工程化
>参考[张云龙：前端工程——基础篇](https://github.com/fouber/blog/issues/10)。

1. 第一阶段：库/框架选型

    >提升开发效率。（使用自动化工具也能够提升开发效率，如浏览器自动刷新、IDE）
2. 第二阶段：简单构建优化

    >提升运行性能。

    对代码进行压缩、校验，以页面为单位进行简单的资源合并。
3. 第三阶段：JS/CSS模块化开发

    >提升维护效率。

    **分而治之**
    1. JS模块化方案：

        CommonJS/AMD/CMD/ES6 Module/UMD
    2. CSS模块化方案：

        sass/less/stylus等预处理器的import、mixin特性支持实现。
4. 第四阶段：前端工程化

    >优化部署、开发。

    1. 组件化开发

        >模块化开发的升华。

        1. 页面上的每个**独立的**可视/可交互区域视为一个组件；
        2. 每个组件对应一个**工程目录**，组件所需的各种资源都在这个目录下**就近维护**；
        3. 由于组件具有独立性，因此组件与组件之间可以**自由组合**；
        4. 页面只不过是组件的容器，负责组合组件形成功能完整的界面；
        5. 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。

    2. 资源管理

        >静态资源加载的技术实现。

        解决思路：
        1. 静态资源管理系统 = 资源表 + 资源加载框架
        2. [大公司的静态资源优化方案](https://github.com/fouber/blog/issues/6)：

            1. 配置超长时间的本地缓存 —— 节省带宽，提高性能
            2. 采用内容摘要（MD5）作为缓存更新依据 —— 精确的缓存控制
            3. 静态资源CDN部署 —— 优化网络请求
            4. 资源发布路径实现非覆盖式发布 —— 平滑升级

### 前端“增量”原则

1. “增量”原则：

    前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。
2. 由“增量”原则引申出的前端优化技巧几乎成为了**性能优化**的核心：

    1. 加载相关的按需加载、延迟加载、预加载、请求合并等策略；
    2. 缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案；
    3. 复杂的BigRender、BigPipe、Quickling、PageCache等技术。

### 页面载入解析步骤
>参考[全方位提升网站打开速度：前端、后端、新的技术](https://github.com/xitu/gold-miner/blob/master/TODO/building-a-shop-with-sub-second-page-loads-lessons-learned.md#前端性能)。

1. 页面载入解析步骤

    ![页面解析步骤图](./images/load-html-1.png)

    1. 增量式生成一个文档对象模型（DOM），解析页面内容（HTML标签）。
    2. 加载DOM中所有CSS，生成一个CSS对象模型（CSSOM），描述对页面内容如何设置样式。

        - 加载CSS和构造完整的CSSOM之前，**阻塞渲染**（Render Tree渲染被暂停）。
    3. 加载DOM中所有JS，对DOM和CSSOM进行访问和更改。

        1. HTML中出现JS，**阻塞解析**（DOM构造被暂停）。
        2. 下载脚本或内嵌脚本不用下载。
        3. 等待所有CSS被提取并且CSSOM被构造完毕。
        4. CSSOM被构造完毕后，执行脚本，访问和更改DOM和CSSOM。
        5. DOM构造继续进行。
    4. DOM和CSSOM构造完成后，进行渲染流水线：

        Render Tree（渲染树） >> Layout（布局）-> Paint（绘制） -> Composite（渲染层合并）。

        >一定要等待外链资源加载完毕（包括加载失败）才可以继续构建DOM或CSSOM。

    >无论阻塞渲染还是阻塞解析，资源文件会不间断按顺序加载。
2. 从输入URL到页面完成的优化

    1. 输入URL：

        >服务端对HTTP请求的优化。

        1. 服务器开启g-zip。
        2. 使用CDN。
        3. 对资源进行缓存：请求头添加Expires、Etags等。
        4. 减少DNS查找，设置合适的TTL值，避免重定向。
    2. 载入页面：

        >前端对CRP（Critical Rendering Path，关键呈现路径，优先显示与当前用户操作有关的内容）、代码性能的优化。

        1. 优化CRP：

            1. 减少关键资源

                首屏资源合并，非首屏资源异步加载。
            2. 最小化字节

                压缩，雪碧图等。

                >单个大文件需要多次与服务器往返来获取。
            3. 缩短CRP长度

                CSS放在HTML顶部，JS放在HTML底部。
        2. 技术上优化：

            1. 单页应用程序。
            2. 首屏直接加载资源，非首屏延迟加载。

                1. 图片延迟加载。
                2. 内容ajax加载。
                3. 功能文件按需加载。
            3. CSS选择器优化。
            4. HTML标签减少层级嵌套。
            5. JS代码性能优化。

### HTTP协议
HTTP（HyperText Transfer Protocol，超文本传输协议）是一个client-server协议，处于整个网络传输的最上层的应用层（网络传输的其他层次：传输层、网络层、链路层）。默认端口号80、无状态（cookie弥补）、以ASCII码传输。

1. HTTP报文组成

    1. request：

        ```http
        <method> <request-URL> <version>                //请求行
        <headers>                                       //请求头

        <entity-body>                                   //请求消息主体
        ```

        >[请求方法](https://github.com/realgeoffrey/knowledge/blob/master/网站前端/前端概念/基础概念.md#http请求方法http-request-methods)。
    2. response：

        ```http
        <version> <status code> <status description>    //状态行
        <headers>                                       //响应头

        <entity-body>                                   //响应正文
        ```

        >[状态码、状态描述](https://github.com/realgeoffrey/knowledge/blob/master/网站前端/前端概念/基础概念.md#http状态码http-status-codes)。

    >[HTTP头](https://github.com/realgeoffrey/knowledge/blob/master/网站前端/前端概念/基础概念.md#http头http-headers)。
2. HTTP流程（精简版）：

    1. 获取域名的IP地址

        >IP协议，网络层协议，解决网络路由和寻址。

        1. 搜索浏览器自身DNS缓存。
        2. 若缓存没找到或者已失效，搜索操作系统DNS缓存。
        3. 若没找到，读取本地HOST文件。
        4. 若没找到，发起一个DNS的系统调用。

            >1. 宽带运营商服务器查看本身缓存。
            >2. 若没找到，运营商服务器发起一个迭代DNS解析的请求。
            >
            >  1. 运营商服务器把结果返回给用户操作系统内核（以上只要成功获取IP地址，每一层都会缓存在自己的系统内以便调用）。
            >  2. 操作系统内核把结果返回浏览器。
    2. 建立TCP／IP连接

        >TCP协议，传输层协议，提供可靠的传递数据包。

        - 发起HTTP“三次握手”（验证客户端），试图建立TCP／IP链接：

            首先客户端向服务端发SYN（同步请求），然后服务端回复SYN+ACK（同步请求应答），最后客户端回复ACK确认。

            >关闭TCP链接要“四次挥手”。
        - 短连接、长连接

            >参考[HTTP长连接和短连接](http://www.cnblogs.com/0201zcr/p/4694945.html)。

            1. 短连接：

                浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束后就中断连接。
            2. 长连接：

                客户端和服务器之间用于传输HTTP数据的TCP连接短期不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
    3. 浏览器发送请求，服务器发送数据

        1. 建立TCP／IP成功后，浏览器即可向服务器发送HTTP请求。
        2. 服务器端接受到了这个请求，根据路径参数、经过后端处理之后，把结果的数据返回浏览器。
    4. 获取所有资源

        若获取的是HTML代码资源，里面的JS、CSS、图片也都必须通过一个个以上完整的HTTP请求步骤进行交通。
    5. 展示

        根据拿到的资源对页面进行渲染，最终呈现完整的页面。

### 浏览器缓存
>参考[浏览器缓存知识小结及应用](http://www.cnblogs.com/lyzg/p/5125934.html)。

1. HTTP协议定义的缓存机制

    1. 强缓存（本地缓存）

        浏览器加载资源时，先根据这个资源之前响应头的`Cache-Control`、`Expires`判断它是否命中强缓存（判断是否到了过期时间）。

        1. 命中状态码：

            `200 OK (from 某某 cache)`
        2. 利用之前HTTP response header返回的`Expires`和`Cache-Control`

            >`Cache-Control`的优先级高于`Expires`。

            1. `Expires`：

                绝对时间。http1.0提出。

                1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，会返回一系列响应头。

                    Expires响应头表示资源过期的绝对时间。
                2. 浏览器在接收到这个资源后，会把这个资源连同所有响应头一起缓存下来。
                3. 浏览器再请求这个资源时，先从缓存中寻找。找到这个资源后，拿出它的Expires跟当前的请求时间进行对比：

                    1. 若请求时间在Expires之前，命中缓存（还要考虑`Cache-Control`），从本地缓存中读取资源，不会发请求到服务器。
                    2. 若没有命中缓存，发请求到服务器，响应头更新这个资源的Expires。
            2. `Cache-Control`：

                相对时间。http1.1提出。

                1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，会返回一系列响应头。

                    Cache-Control响应头表示（相对于请求发起时间的）资源过期的相对时间。
                2. 浏览器在接收到这个资源后，会把这个资源连同所有响应头一起缓存下来。
                3. 浏览器再请求这个资源时，先从缓存中寻找。找到这个资源后，根据它请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间进行对比：

                    1. 若请求时间在过期时间之前，命中缓存（还要考虑`Expires`），从本地缓存中读取资源，不会发请求到服务器。
                    2. 若没有命中缓存，发请求到服务器，响应头更新这个资源的Cache-Control。

        >建议：[配置超长时间的本地缓存；采用内容摘要（MD5）作为缓存更新依据](https://github.com/fouber/blog/issues/6)。
    2. 协商缓存

        若没有命中强缓存，浏览器发送一个请求到服务器，根据这个资源的`ETag/If-None-Match`、`Last-Modified/If-Modified-Since`判断它是否命中协商缓存（判断缓存资源和服务端资源是否一致）。

        1. 命中状态码：

            `304 Not Modified`
        2. 利用之前HTTP response header返回的`Last-Modified`、`ETag`与HTTP request head发起的`If-Modified-Since`、`If-None-Match`

            >`ETag/If-None-Match`的优先级高于`Last-Modified/If-Modified-Since`。

            1. `Last-Modified`与`If-Modified-Since`：

                绝对时间。服务器时间。秒级。

                1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，会返回一系列响应头。

                    Last-Modified响应头表示这个资源在服务器上的最后修改时间。
                2. 浏览器在接收到这个资源后，会把这个资源连同所有响应头一起缓存下来。
                3. 浏览器再请求这个资源时，带上If-Modified-Since请求头（Last-Modified的值）。
                4. 服务器收到资源请求时，拿If-Modified-Since和资源在服务器上最后修改时间进行对比：

                    1. 若没有变化，命中缓存（还要考虑`ETag/If-None-Match`），返回304 Not Modified，但不返回资源内容。浏览器从本地缓存中读取资源。
                    2. 若没有命中缓存，则返回资源内容，响应头更新这个资源的Last-Modified。
            2. `ETag`与`If-None-Match`：

                1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，会返回一系列响应头。

                    ETag响应头表示这个资源在服务器上的唯一标识字符串，只要资源有变化这个串就改变。
                2. 浏览器在接收到这个资源后，会把这个资源连同所有响应头一起缓存下来。
                3. 浏览器再请求这个资源时，带上If-None-Match请求头（ETag的值）。
                4. 服务器收到资源请求时，拿If-None-Match和资源在服务器上生成新的ETag进行对比：

                    1. 若值相同，命中缓存（还要考虑`Last-Modified/If-Modified-Since`），返回304 Not Modified，但不返回资源内容。浏览器从本地缓存中读取资源。（由于ETag重新生成过，）响应头更新这个资源的ETag。
                    2. 若没有命中缓存，则返回资源内容，响应头更新这个资源的ETag。

                >1. 分布式部署，多台机器的Last-Modified必须保持一致。
                >2. 分布式系统尽量关闭ETag(每台机器生成的ETag都会不一样）。

            - 产生`ETag`的必要性

                1. 某些文件也许会周期性的更改，但是他的内容并不改变（仅仅改变的修改时间），这时不希望客户端认为这个文件被修改了，而重新GET。
                2. 某些文件修改非常频繁，比如在1秒的时间内进行修改，If-Modified-Since能检查到的粒度是秒级的，这种修改无法判断（或者说UNIX记录MTIME只能精确到秒）。
                3. 某些服务器不能精确的得到文件的最后修改时间。

    - 联系：

        1. 相同：

            1. 如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据。
            2. 只有GET请求会被缓存，POST请求不会。
        2. 区别：

            1. 强缓存不发请求到服务器，协商缓存会发请求到服务器。
            2. 用户行为影响缓存使用情况

                | 用户操作 | 强缓存 | 协商缓存 |
                | :--- | :---: | :---: |
                | 地址栏回车 | 有效 | 有效 |
                | 页面链接跳转 | 有效 | 有效 |
                | 新开窗口 | 有效 | 有效 |
                | 前进、后退 | 有效 | 有效 |
                | 刷新 | **无效** | 有效 |
                | 强制刷新 | **无效** | **无效** |
2. 其他缓存机制（不建议）

    1. HTML的`meta`标签设置缓存情况：

        e.g. 设置不缓存：

        ```html
        <meta http-equiv="pragma" content="no-cache">
        <meta http-equiv="cache-control" content="no-cache">
        <meta http-equiv="expires" content="0">
        ```
    2. html标签属性`manifest`应用程序缓存：

        ```html
        <html manifest=".manifest文件/.appcache文件">
        ```

### 垃圾回收
>垃圾回收器会按照固定的时间间隔（或代码执行中预定的时间）周期性地执行，找出不再继续使用的变量，然后释放其占用的内存。

垃圾回收器必须跟踪并判断变量是否有用，对于不再有用的变量打上标记，以备将来回收。

1. **标记清除（mark-and-sweep）**（现代浏览器使用方式）

    垃圾回收器在运行时给存储在内存中的所有变量加上标记；然后，去掉环境中的变量以及被环境中变量引用的变量的标记；最后，对那些带标记的值进行释放。
2. 引用计数（reference counting）

    跟踪记录每个值被引用的次数，被引用一次加1，引用取消就减1，当引用次数为0时，则说明没有办法再访问这个值了，当垃圾回收器下次运行时，释放引用次数为0的值所占空间。

    >可能产生一个严重的问题：循环引用，引用次数永远不会是0。

>用`变量 = null;`等方法，让变量成为零引用，从而进行清除元素、垃圾回收（导致内存泄露的情况除外）。

### 自动插入分号机制（Automatic Semicolon Insertion，ASI）
1. ASI机制不是说在解析过程中解析器自动把分号添加到代码中，而是说解析器除了分号还会以换行为基础按一定的规则作为断句（EOC）的依据，从而保证解析的正确性。
2. 解析器会尽量将新行并入当前行，当且仅当符合ASI规则时才会将新行视为独立的语句：

    1. `;`空语句
    2. `var`语句
    3. 表达式语句（一定会产生一个值）
    4. `do-while`语句（不是`while`）
    5. `continue`语句
    6. `break`语句
    7. `return`语句
    8. `throw`语句

>前置分号策略：只要对行首字符进行token判断是否为：`[` `(` `+` `-` `/`五个符号之一，就在其前面增加分号。